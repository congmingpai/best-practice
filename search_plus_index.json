{"./":{"url":"./","title":"README","keywords":"","body":"聪明派软件开发最佳实践 不积跬步，无以至千里；不积小流，无以成江海。 -- 荀子《劝学篇》 前言 一转眼，聪明派一岁了。在这一年多的时间里，我们技术团队完成了很多很有挑战的目标，每个人都为项目贡献了自己力量，积累了大量的代码和经验。但快速向前奔跑的同时，我们没能很好的归纳总结工作中得到的经验，更没能把这些经验分享出来，让大家一起受益，这是很可惜的。所幸改变从任何时候开始都不晚，从现在起，将日常开发中碰到的问题一起探讨一起总结，日后就会汇聚成能让所有人受益的宝贵财富。 Greg Wang06/16/2019 "},"general/style.html":{"url":"general/style.html","title":"代码风格","keywords":"","body":"代码风格 TypeScript TypeScript(和 JavaScript)的代码风格上统一使用 prettier 风格 + airbnb 规范， 并用standard 规范加以补充。 标准间有冲突时，优先级是 prettier > airbnb > standard 。 Airbnb 规范 ES6 版中文参考：https://github.com/yuche/javascript Standard 规范中文参考：https://standardjs.com/rules-zhcn.html tslint 基础配置 { \"extends\": [\"tslint-config-standard\", \"tslint-config-airbnb\", \"tslint-config-prettier\"] } "},"general/naming.html":{"url":"general/naming.html","title":"命名规范","keywords":"","body":"命名规范 统一的命名风格能让我们快速地了解某个名字代表的含义，而不需要去查找原始声明。 命名格式规范 类型 代码命名 举例 类 (class) 大写驼峰 class FooBar {...} 类成员 (class member) 小写驼峰 private fooBar: number = 0; 类方法 (class method) 小写驼峰 private fooBar(): boolean {...} 函数 (function) 小写驼峰 function fooBar(): boolean {...} 参数 (parameter) 小写驼峰 private do(fooBar: number): boolean {...} 变量 (variable) 小写驼峰 const fooBar = 0; 常量 (constant) 全大写+下划线 const FOO_BAR = 0; 枚举 (enumeration) 大写驼峰+单数 enum FooBar { FOO_BAR }; 接口 (interface) 大写驼峰+单数 interface FooBar {...}; 类型 (type) 大写驼峰+单数 type FooBar = int; 命名约定 通用规则 命名要具有描述性； 只使用人尽皆知的缩写，不要担心过长，让代码易于新读者理解更重要； 避免增加无附加意义的词语； 不要使用系统保留词语，如 return switch 或 Cocos 中的 start update。 // GOOD const window; const completedQuestionCount; const failedRoundCount; class FlipCoinGameController {} const clientIp; // 人人都知道IP是什么意思 // BAD const w; // 毫无意义 const countCmp; // 含糊不清的缩写 const failedRdCnt; // 删减字母后难以理解 class FCGameCtl {} // FC有很多种解释，只有作者才能理解 // More BAD const data; // 各种东西都可以是data const userInfo = findUser(); // user已经足够具体，Info没有给命名增加额外信息。 function doCreateObject() {}; // do是个没有明确意义的动词，所以应该省略；createObject足够具体清晰。 类 (class)，接口 (Interface)，类型 (type)，枚举 (enumeration) [!TIP] 面向对象编程中，对象代表着一个具体的事物，而类是对象的模版，用来统一表示一种类型的事物，所以类的命名要以描述这一事物类型为目的。接口和类型同理。 对类命名时， 后缀应表示事物的根本类型，以名词结尾； 前缀对后缀所表示的事物进行修饰，进一步限制含义。 // GOOD class EnrollmentManagerTestSuite {} // EnrollmentManager的测试用例 class ReviewConfigCsvParser extends CsvParser {} // 用于ReviewConfig的csv解析器 // BAD class TestEnrollmentManager {} // 后缀没有表示事物的根本类型是测试用例，而不是Manager class ReviewConfigParse extends CsvParser {} // 不能以动词结尾 方法 (method)，函数 (function) 方法和函数的命名是用于描述一段逻辑。命名需以动词开头，动词后附加细节来进一步限定含义。 // GOOD authService.loginWithWechat(code); submitLoginForm(formData); moveUpAndDown(node); // BAD authService.wechatLogin(); // 没有动词开头 formSubmit(formData); // 没有动词开头 jump(node); // 没有限定jump的目的，jumpToXxx会更明确；或作为方法名时，node.jump()可以理解。 几种常见有特殊意义的函数/方法名前缀，只应在特定的情况下使用。 命名 例子 解释 isXxx isInteger 检查类型并返回 boolean checkXxx checkParams 检查内容并返回 boolean validateXxx validateParams 校验类型/内容，失败抛出异常 convertToXxx / toXxx convertToString / toString 转换类型/格式为 Xxx setXxx setGameSpeed 设定某个 property 的值 getXxx getDuration 获取某个 property 的值 onXxxx onClicked Xxx 事件的响应逻辑 (handler) willXxx / aaaWillXxx / preXxx componentWillMount / preRender Xxx 事件发生前的钩子 (prehook) didXxx / aaaDidXxx / postXxx componentDidMount / postRender Xxx 事件发生前的钩子 (prehook) 变量 (variable)，类成员 (class member)，常量 (constant) 变量和类成员命名时，应以名词结尾，辅以细节修饰。常见情况有， 情况 方法 例子 引用一个对象 以对象的类型为结尾 const newUser = new User() 对象数组/集合 以对象的类型为结尾，复数(+s) const users = findUsers() 过滤过的数组/集合 增加前缀修饰 const activeUsers = users.filter(user => user.isActive) 计数 以 count 结尾 const userCount = users.length 映射 以 map 结尾 const idToUserMap = new Map() 集合 以 set 结尾 const userSet = new Set(users) // GOOD const stagePrefab: cc.Prefab; const stageNode = this.loadNextStageNode(stagePrefab); const tableRows = table.rows; // BAD const stage: cc.Prefab; // 没有体现stage的类型是cc.Prefab const stage = this.loadNextStage(this.stage); // 1. 没有体现stage的类型是cc.Node 2. 本地变量stage和this.stage重名但引用了不同的对象+类型 const rowList = table.rows; // 列表应以复数命名结尾，不应用List。 几种常见有特殊意义的变量前缀，只应在特定的情况下使用。 命名 例子 解释 isXxx const isValidUser = checkUser(user); 记录检查结果的 boolean hasXxx const hasEnoughMoney = money > price; 表示拥有 xxx 的 boolean "},"general/convention.html":{"url":"general/convention.html","title":"代码准则","keywords":"","body":"代码准则 通用 Early Return 当一个函数已经可以得到计算结果时，尽可能早的返回。 // GOOD () => { const a = checkA(); if (!a) { return; } const b = checkB(); if (!b) { return; } ... } // BAD () => { const a = checkA(); if (a) { const b = checkB(); if (b) { const c = checkC(); if (c) { ... } } } } 纯函数 Pure function 相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，即为纯函数。 纯函数的好处是： 可移植/可复用 可测试 可缓存 可替换 参考：纯函数的好处 // GOOD function plus(a, b) { return a + b; } const c = plus(1, 2); console.log(c); // BAD1：函数有副作用（修改了外部状态），不是纯函数 let c = 0; function plusWithSideEffect(a, b) { c = a + b; } plusWithSideEffect(1, 2); console.log(c); // BAD2：函数依赖于外部状态，输入 let b = 2; function plusNotPure(a) { return a + b; } const c = plusNotPure(1); console.log(c); "},"general/typing.html":{"url":"general/typing.html","title":"类型安全","keywords":"","body":"类型安全 入门 TypeScript 在 React 中使用总结 常见问题 回调函数的参数类型不确定 回调函数的参数类型通常可以通过找到原函数的定义来获得。 interface DoSomethingResult { val: string } function doSomething(onComplete: (result: DoSomethingResult) => void) {...} // BEST function callback(result: DoSomethingResult) {...} doSomething(callback); // GOOD function callback(result: { val: string }) {...} doSomething(callback); // BAD function callback(result: any) {...} doSomething(callback); React 中常用的 Event 事件类型有 ClipboardEvent 剪贴板事件对象 DragEvent 拖拽事件对象 ChangeEvent Change 事件对象 KeyboardEvent 键盘事件对象 MouseEvent 鼠标事件对象 TouchEvent 触摸事件对象 WheelEvent 滚轮事件对象 AnimationEvent 动画事件对象 TransitionEvent 过渡事件对象 参考：https://juejin.im/post/5bab4d59f265da0aec22629b#heading-13 Taro 中的 Event 事件类型主要继承了 BaseEventOrig，常见还有 ITouchEvent 触摸事件 "},"general/productivity.html":{"url":"general/productivity.html","title":"工作方式","keywords":"","body":"工作方式 复盘总结 避免每次代码迭代修改量过大 更细致的拆分需求 拆分实施步骤 每个步骤完成后即可验证结果 优先合并已验证的结果 好文 2019 年程序员最值得学习的思维利器——任务分解 Code Review 最佳实践 修复每个 bug 后都要问这 3 个问题 "},"backend/architecture.html":{"url":"backend/architecture.html","title":"后端架构","keywords":"","body":"后端架构设计 整体架构 依赖注入 我们使用typedi作为依赖注入框架。 避免使用 constructor 注入 Constructor 注入虽然方便，但在出现循环依赖等复杂情况时灵活性和稳定性不足，所以我们建议大家使用属性注入替代。 // GOOD @Service() class ServiceA { @Inject() private serviceB: ServiceB; } // BAD @Service() class ServiceA { constructor(private serviceB: ServiceB) {} } 解决循环引用 官方文档 发生循环引用时，一般可以通过给 @Inject()添加类型回调函数解决，如 @Inject(type => ServiceA)。 需要注意的是，通常循环引用意味着 模块间的责任分工不明 单个模块的责任过多（非单一责任设计） 缺少合理的抽象层 这些问题应该最终通过调整架构设计并重构解决。 "},"backend/api.html":{"url":"backend/api.html","title":"API 开发","keywords":"","body":"API 开发 错误处理 ctx.throw 例如：https://github.com/gregwym/smartpi-server/pull/1423 全局修复: https://github.com/gregwym/smartpi-server/pull/1436 // GOOD ctx.throw(400, 'Sku ID is required'); ctx.throw(400, 'Sku ID is required'); // BAD ctx.throw('Sku ID is required'); // 默认500 ctx.throw(400); // Sentry只会收到Bad Request的错误消息，没有具体信息 "},"frontend/jsx.html":{"url":"frontend/jsx.html","title":"JSX 开发","keywords":"","body":"JSX 开发（React&Taro 通用） 状态管理 state 用于保存组件中会发生变化的状态值，一般是会由外因导致变化的值（如用户操作/输入）。组件设计开发时应避免过多的 state，以免组件的状态难以跟踪。 只负责数据展示的 presentation 组件不需要状态。 不要将数据保存在成员变量中 只有 props 和 state 的变化会触发重新渲染，将数据保存在成员变量中会导致页面不会渲染最新的数据。 不要用 state 保存渲染的中间状态 任何通过原始数据计算或重组以供渲染用的中间状态应作为 render 的本地变量，在每次渲染时重新计算。 // GOOD function XxxComponent(props) { const itermediateValues = props.vals.map(val => { ... }); return {itermediateValues} } // BAD class XxxComponent { componentDidMount() { const itermediateValues = props.vals.map(val => { ... }); this.setState({ itermediateValues }); } render() { return {this.state.itermediateValues} } } 渲染优化 通过循环渲染一系列子组件时，不要用下标(index)作为key // GOOD: 使用来源数据的ID作为key { props.items.map(item => {item.value}); } // GOOD: 使用来源数据中的某个唯一值作为key { props.items.map(item => {item.value}); } // GOOD: 使用来源数据中的多个值拼成的唯一值作为key { props.items.map(item => {item.value}); } // BAD: 使用下标作为key是反优化 { props.items.map((item, i) => {item.value}); } "},"unsorted/timer.html":{"url":"unsorted/timer.html","title":"计时器","keywords":"","body":"计时器 使用包装好的计时器 Cocos 环境 ActiveTimer Web 前端环境 组件（待实现） 组件（待实现） 常见错误 启动时应先检查并清除已经在运行的 timer，以防重复启动。 "}}